syntax = "proto3";

package slsa.v1;

import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";

// Design guidelines:
//
// -   Use lowerCamelCase for field names because that is how the JSON fields
//     are named. The proto style guide advises use of snake_case in the .proto
//     file but lowerCamelCase in JSON, but we believe that is confusing for
//     readers (since we always serialize to JSON). It also makes it harder to
//     reference other fields in comments since there are two ways to reference
//     a field.
//
// -   Prefer field names that are unique throughout the file, even if somewhat
//     redundant with the parent field. This makes it easier to reference in
//     documentation and reduces confusion.

message Provenance {
  // The input to the build.
  //
  // The accuracy and completeness of this information is implied by
  // `runDetails.builder.id`.
  //
  // REQUIRED for SLSA Build L1.
  BuildDefinition buildDefinition = 1;

  // Details specific to this particular execution of the build.
  //
  // REQUIRED for SLSA Build L1.
  RunDetails runDetails = 2;
}

message BuildDefinition {
  // [TypeURI] indicating how to unambiguously interpret this message and
  // initiate the build.
  //
  // This SHOULD resolve to a human-readable specification that includes:
  //
  // -   Overall description.
  // -   List of all parameters, including:
  //     -   name
  //     -   description
  //     -   external vs system
  //     -   artifact vs value
  //     -   required vs optional
  //     -   any other restrictions
  // -   Explicit, unambiguous instructions for how to initiate the build given
  //     this message.
  //
  // REQUIRED.
  string buildType = 1;

  // The set of top-level external inputs to the build. This SHOULD contain all
  // the information necessary and sufficient to initialize the build and begin
  // execution. "Top-level" means that it is not derived from another input.
  //
  // The interpretation of each parameter is determined by `buildType`.
  //
  // The build system SHOULD be designed to minimize the amount of information
  // necessary here, in order to reduce fragility and ease verification.
  // Consumers SHOULD have an expectation of what "good" looks like; the more
  // information that they must check, the harder that task becomes.
  //
  // Guidelines:
  //
  // -   Maximize the amount of information that is implicit from the meaning of
  //     `buildType`. In particular, any value that is boilerplate and the same
  //     for every build SHOULD be implicit.
  //
  // -   Reduce parameters by moving configuration to input artifacts whenever
  //     possible. For example, instead of passing in compiler flags via a
  //     parameter, require them to live next to the source code or build
  //     configuration.
  //
  // -   If possible, architect the build system to use this definition as its
  //     sole top-level input, in order to guarantee that the information is
  //     sufficient to run the build.
  //
  // -   In some cases, the build configuration is evaluated client-side and
  //     sent over the wire, such that the build system cannot determine its
  //     origin. In those cases, the build system SHOULD serialize the
  //     configuration in a deterministic way and record the `digest` without a
  //     `uri`. This allows one to consider the client-side evaluation as a
  //     separate "build" with its own provenance, such that the verifier can
  //     chain the two provenance attestations together to determine the origin
  //     of the configuration.
  //
  // SHOULD be sorted by `name` to make the provenance deterministic.
  //
  // TODO: Describe how complete this must be at each SLSA level.
  //
  // TODO: Some requirement that the builder verifies the URI and that the
  // verifier checks it against expectations?
  //
  // REQUIRED for SLSA Build L1.
  repeated Parameter externalParameters = 2;

  // Parameters of the build environment that were provided by the `builder` and
  // not under external control. The primary intention of this field is for
  // debugging, incident response, and vulnerability management. The values here
  // MAY be necessary for reproducing the build.
  //
  // The interpretation of each parameter is determined by `buildType`.
  //
  // SHOULD be sorted by `name` to make the provenance deterministic.
  //
  // OPTIONAL.
  repeated Parameter systemParameters = 3;

  // Resolved dependencies needed at build time. For example, if the build
  // script fetches and executes "example.com/foo.sh", which in turn fetches
  // "example.com/bar.tar.gz", then both "foo.sh" and "bar.tar.gz" should be
  // listed here.
  //
  // Any artifacts listed under `externalParameters` or `systemParameters`
  // SHOULD NOT be repeated here.
  //
  // TODO: Explain what the purpose of this field is. Why do we need it?
  // TODO: Explain how to determine what goes here.
  // TODO: Explain that it's OK for it to be incomplete.
  // TODO: If the dep is already pinned, does it need to be listed here?
  // TODO: Should this be a Parameter instead of ArtifactReference? On the one
  //       hand, that would allow specification on scalar values. On the other,
  //       it would require each to be explicitly named (could be good or bad).
  //
  // OPTIONAL.
  repeated ArtifactReference resolvedDependencies = 1;
}

message Parameter {
  // The name of this parameter. Must be unique across `externalParameters` and
  // `systemParameters`.
  //
  // The following conventional names are RECOMMENDED when appropriate:
  //
  // name     | description
  // -------- | -----------
  // `source` | The primary input to the build.
  // `config` | The build configuration, if different from `source`.
  //
  string name = 1;

  oneof value_type {
    // A parameter value that is a reference to an artifact.
    ArtifactReference artifact = 2;
    // A scalar parameter value. For simplicity, only string type is supported.
    string value = 3;
  }
}

message ArtifactReference {
  // [URI] describing where this artifact came from. When possible, this SHOULD
  // be a universal and stable identifier, such as a source location or Package
  // URL ([purl]).
  //
  // Example: `pkg:pypi/pyyaml@6.0`
  string uri = 1;

  // [DigestSet] of cryptographic digests for the contents of this artifact.
  // TODO: Decide on hex vs base64 in #533 then document it here.
  map<string, string> digest = 2;

  // The name for this artifact local to the build.
  //
  // Example: `PyYAML-6.0.tar.gz`
  string localName = 3;

  // [URI] identifying the location that this artifact was downloaded from, if
  // different and not derivable from `uri`.
  //
  // Example: `https://files.pythonhosted.org/packages/36/2b/61d51a2c4f25ef062ae3f74576b01638bebad5e045f747ff12643df63844/PyYAML-6.0.tar.gz`
  string downloadLocation = 4;

  // [Media Type] (aka MIME type) of this artifact.
  string mediaType = 5;
}

message RunDetails {
  // TODO: The following fields are the same as v0.2:
  //
  // REQUIRED for SLSA Build L1 unless the id is implicit from the attestation
  // envelope (e.g. public key).
  Builder builder = 1;

  // TODO: description
  // OPTIONAL
  BuildMetadata metadata = 2;

  // Additional artifacts generated during the build that should not be
  // considered the "output" of the build but that may be needed during
  // debugging or incident response.
  //
  // Possible use cases:
  //
  // -   Logs generated during the build.
  // -   Fully evaluated build configuration.
  //
  // In most cases, this SHOULD NOT contain all intermediate files generated
  // during the build. Instead, this should only contain files that are likely
  // to be useful later and that cannot be easily reproduced.
  //
  // TODO: Do we need some recommendation for how to distinguish between
  // byproducts? For example, should we recommend using `localName`?
  //
  // OPTIONAL
  repeated ArtifactReference byproducts = 3;
}

message Builder {
  // [URI] ... (same as v0.2)
  // TODO: In most cases this is implicit from the envelope layer (e.g. the
  // public key or x.509 certificate), which is just one more thing to mess up.
  // Can we rescope this to avoid the duplication and thus the security concern?
  // For example, if the envelope identifies the build system, this might
  // identify the tenant project?
  //
  // REQUIRED for SLSA Build L1 unless the id is implicit from the attestation
  // envelope (e.g. public key).
  string id = 1;

  // TODO: Do we want to add this field? (#319)
  // TODO: Should we merge this with builderDependencies into a combined
  // "builderParameters"? Then arbitrary information can be stored.
  //
  // OPTIONAL
  map<string, string> version = 2;

  // Dependencies used by the orchestrator that are not run within the workload
  // and that should not affect the build, but may affect the provenance
  // generation or security guarantees.
  // TODO: Flesh out this model more.
  //
  // OPTIONAL
  repeated ArtifactReference builderDependencies = 3;
}

message BuildMetadata {
  // TODO: same as v0.2:
  // OPTIONAL
  string invocationId = 1;

  // OPTIONAL
  google.protobuf.Timestamp startedOn = 2;

  // OPTIONAL
  google.protobuf.Timestamp finishedOn = 3;
}
